#include "llvm/IR/Constants.h"
#include "llvm/IR/Function.h"
#include "llvm/IR/InstIterator.h"
#include "llvm/IR/Instructions.h"
#include "llvm/IR/LegacyPassManager.h"
#include "llvm/IR/Module.h"
#include "llvm/IR/Type.h"
#include "llvm/Pass.h"
#include "llvm/Support/raw_ostream.h"
#include <fcntl.h>

#include "llvm/Passes/PassBuilder.h"
#include "llvm/Passes/PassPlugin.h"
#include "llvm/Support/CommandLine.h"

// completely arbitrary, will need something that makes sense eventually
#define MAGIC_THRESHOLD 512

using namespace llvm;

static cl::opt<bool> WriteToTerminal(
    "write-to-terminal", cl::Hidden,
    cl::desc("Set write to terminal instead of to a file (default: false)."),
    cl::init(false));

#define DEBUG_TYPE "memory-xml-writer"

namespace {

int indent;
struct IdentRAII {
  int &indent;
  IdentRAII(int &indent) : indent(indent) {}
  ~IdentRAII() { --indent; }
};

void resetIndent() { indent = 0; }

IdentRAII pushIndent() { return IdentRAII(++indent); }

raw_ostream *outputStream;

raw_ostream &xmlOut() { return *outputStream; }

llvm::raw_ostream &printIndent() {
  for (int i = 0; i < indent; ++i)
    xmlOut() << " ";
  return xmlOut();
}

void printPreamble() {
  printIndent() << "<?xml version=\"1.0\"?>\n"
                << "<memory>\n";
  auto indent = pushIndent();
  printIndent() << "<memory_allocation>\n";
}

void printClosure() {
  printIndent() << "</memory_allocation>\n";
  resetIndent();
  printIndent() << "</memory>\n";
}

bool runXMLWriterPass(Module &M) {
    std::error_code errorMessage;
    StringRef fileName = "memory_allocation.xml";
    raw_fd_ostream outFile(fileName, errorMessage);
    outputStream = &outFile;

    if (WriteToTerminal) {
      outputStream = &llvm::outs();
    }

    resetIndent();
    printPreamble();
    auto indent = pushIndent();
    {
      for (auto f = M.begin(), fE = M.end(); f != fE; ++f) {
        if (!(*f).isDeclaration()) {
          for (auto I = inst_begin(*f), E = inst_end(*f); I != E; ++I) {
            if (isa<AllocaInst>(*I)) {
              if (MDNode *N = (*I).getMetadata("annotation")) {
                auto indent = pushIndent();
                printIndent() << "<object scope=\"" << (*f).getName() << "\" ";
                xmlOut() << "name=\""
                         << cast<MDString>(N->getOperand(0))->getString()
                         << "\" ";
                xmlOut() << "is_internal=\"";
                uint64_t total_size = 0;
                uint64_t array_size = 0;
                DataLayout *d = new DataLayout(&M);
                if (cast<AllocaInst>(*I).getAllocationSizeInBits(*d) ==
                    std::nullopt) {
                  Value *v = cast<AllocaInst>(*I).getArraySize();
                  Value *first_op = dyn_cast<ConstantExpr>(v)->getOperand(0);
                  Value *first_op_second_op =
                      dyn_cast<ConstantExpr>(first_op)->getOperand(1);
                  array_size =
                      dyn_cast<ConstantInt>(first_op_second_op)->getZExtValue();
                  Type *t = cast<AllocaInst>(*I).getAllocatedType();
                  total_size = d->getTypeAllocSizeInBits(t) * array_size;
                } // else branch is provisionally missing because up to now all
                  // models generated by MLIR follow this pattern
                if (total_size > MAGIC_THRESHOLD) {
                  xmlOut() << "F\"";
                } else {
                  xmlOut() << "T\"";
                }
                xmlOut() << "/>\n";
              }
            }
          }
        }
      }
    }

    printClosure();
    return true;
  }

struct XMLWriterPass : public PassInfoMixin<XMLWriterPass> {
  PreservedAnalyses run(Module &M, ModuleAnalysisManager &) {
    runXMLWriterPass(M);
    return PreservedAnalyses::all();
  }
};
} // end of anonymous namespace

/* New PM Registration */
llvm::PassPluginLibraryInfo getXMLWriterPluginInfo() {
  return {LLVM_PLUGIN_API_VERSION, "XMLWriter", LLVM_VERSION_STRING,
      [](PassBuilder &PB) {
      PB.registerPipelineParsingCallback(
        [](StringRef Name, llvm::ModulePassManager &MPM,
           ArrayRef<llvm::PassBuilder::PipelineElement>) {
          if (Name == "xml-mem-writer") {
          MPM.addPass(XMLWriterPass());
          return true;
          }
          return false;
        });
      }};
}

#ifndef LLVM_XMLWRITER_LINK_INTO_TOOLS
extern "C" LLVM_ATTRIBUTE_WEAK ::llvm::PassPluginLibraryInfo
llvmGetPassPluginInfo() {
  return getXMLWriterPluginInfo();
}
#endif
